/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.9 2005/01/07 09:37:18 dts12 Exp $
 */


#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/time.h>

#include "tr069/tr069_token.h"
#include "tr069/tr069_store.h"
#include "tr069/tr069_index.h"

#define SDEBUG
#include "tr069/dm_assert.h"
#include "tr069/debug.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include "snmp_helper.h"
#include "radiusAccClient.h"

static oid radiusAccClient_oid[] = { 1, 3, 6, 1, 2, 1, 67, 2, 2, 1, 1 };

#define radiusAccClientInvalidServerAddresses_oid	1
#define radiusAccClientIdentifier_oid			2
#define radiusAccServerTable_oid			3
#define radiusAccServerExtTable_oid			4

static int
radiusAccClient_handler(netsnmp_mib_handler *handler,
			 netsnmp_handler_registration *reginfo,
			 netsnmp_agent_request_info *reqinfo,
			 netsnmp_request_info *requests);

/** Initializes the radiusAccClient module */
void
init_radiusAccClient(void)
{
	netsnmp_handler_registration *reginfo;

	/*
	 * register ourselves with the agent as a group of scalars...
	 */
 
	DEBUGMSGTL(("radiusAccClient", "Initializing\n"));

	reginfo = netsnmp_create_handler_registration("radiusAccClient",
						      radiusAccClient_handler,
						      radiusAccClient_oid, OID_LENGTH(radiusAccClient_oid),
						      HANDLER_CAN_RONLY);
	netsnmp_register_scalar_group(reginfo, radiusAccClientInvalidServerAddresses_oid, radiusAccServerExtTable_oid);
}

int
radiusAccClient_handler(netsnmp_mib_handler *handler,
		       netsnmp_handler_registration *reginfo,
		       netsnmp_agent_request_info *reqinfo,
		       netsnmp_request_info *requests)
{
	netsnmp_request_info  *request;
	netsnmp_variable_list *requestvb;
	unsigned int ret_value = 0;
	oid      subid;
	int      type;

	ENTER();

	/*
	 * 
	 *
	 */
	DEBUGMSGTL(("radiusAccClient", "Handler - mode %s\n", se_find_label_in_slist("agent_mode", reqinfo->mode)));
	switch (reqinfo->mode) {
	case MODE_GET:
		for (request = requests; request; request = request->next) {
			requestvb = request->requestvb;
			subid = requestvb->name[OID_LENGTH(radiusAccClient_oid)];  /* XXX */

			type = ASN_COUNTER;

			DEBUGMSGTL(( "radiusAccClient", "oid: "));
			DEBUGMSGOID(("radiusAccClient", requestvb->name, requestvb->name_length));
			DEBUGMSG((   "radiusAccClient", "\n"));
			switch (subid) {
			case radiusAccClientInvalidServerAddresses_oid:
				/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusServer.Accounting.Stats */
				ret_value = tr069_get_uint_by_selector((tr069_selector){ cwmp__InternetGatewayDevice,
							cwmp__IGD_X_TPLINO_NET_SessionControl,
							cwmp__IGD_SCG_RadiusClient,
							cwmp__IGD_SCG_RC_Accounting,
							cwmp__IGD_SCG_RC_Acct_Stats,
							cwmp__IGD_SCG_RC_Acct_Stats_InvalidServerAddresses, 0});
				break;

			case radiusAccClientIdentifier_oid:
				snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (unsigned char *)"", 0);
				continue;

			case radiusAccServerTable_oid:
			case radiusAccServerExtTable_oid:
				/*
				 * These are not actually valid scalar objects.
				 * The table registration should take precedence,
				 *   so skip thess subtree, regardless of architecture.
				 */
				netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
				continue;
			}
			snmp_set_var_typed_value(request->requestvb, type, (u_char *)&ret_value, sizeof(ret_value));
		}
		break;

	case MODE_GETNEXT:
	case MODE_GETBULK:
	case MODE_SET_RESERVE1:
	case MODE_SET_RESERVE2:
	case MODE_SET_ACTION:
	case MODE_SET_COMMIT:
	case MODE_SET_FREE:
	case MODE_SET_UNDO:
		snmp_log(LOG_WARNING, "radiusAccClient: Unsupported mode (%d)\n", reqinfo->mode);
		break;
	default:
		snmp_log(LOG_WARNING, "radiusAccClient: Unrecognised mode (%d)\n", reqinfo->mode);
		break;
	}
	
	return SNMP_ERR_NOERROR;
}
