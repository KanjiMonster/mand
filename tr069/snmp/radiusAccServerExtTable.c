/*
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.26 2005/04/26 22:13:28 rstory Exp $
 *
 * $Id:$
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial-5/
 *
 *
 * You can also join the #net-snmp channel on irc.freenode.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 *
 */

#include <netdb.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/time.h>

#include "libradius/radlib.h"

#include "tr069/tr069_token.h"
#include "tr069/tr069_store.h"
#include "tr069/tr069_index.h"

#define SDEBUG
#include "tr069/dm_assert.h"
#include "tr069/debug.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include "snmp_helper.h"
#include "radiusAccServerExtTable.h"
#include "radiusMIB_enums.h"

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;

static oid radiusAccServerExtTable_oid[] = { radiusAccServerExtTable_TABLE_OID };
static size_t radiusAccServerExtTable_oid_len = OID_LENGTH(radiusAccServerExtTable_oid);

static void initialize_table_radiusAccServerExtTable(void);
static int radiusAccServerExtTable_get_value(netsnmp_request_info *, netsnmp_index *, netsnmp_table_request_info *);

/**
 * Add a new client
 */
void
add_radiusAccServerExtTable(tr069_id id, struct tr069_value_table *client)
{
	radiusAccServerExtTable_context *row;

	ENTER();

	if (!my_handler) {
		EXIT();
		return;
	}

	row = malloc(sizeof(radiusAccServerExtTable_context));
	if (!row) {
		EXIT();
		return;
	}

	row->radiusAccClientCounterDiscontinuity = ltime();
	row->index.len = 1;
	row->index.oids = &row->oid[0];
	row->oid[0] = id;
	row->radiusAccServerExtIndex = id;
	row->client = client;
	debug("inserting row: %d (%p), client: %p", id, row, client);
	CONTAINER_INSERT(cb.container, row);

	EXIT();
}

/**
 * Remove a client
 */
void
del_radiusAccServerExtTable(tr069_id id)
{
	netsnmp_index idx;
	oid soid[1];
	radiusAccServerExtTable_context *row;

	if (!my_handler)
		return;

	idx.len = 1;
	idx.oids = &soid[0];
	soid[0] = id;

	row = CONTAINER_FIND(cb.container, &idx);
	if (row) {
		CONTAINER_REMOVE(cb.container, row);
		free(row);
	}
}

/************************************************************
 * Initializes the radiusAccServerExtTable module
 */
void
init_radiusAccServerExtTable()
{
	struct tr069_instance *rs;
	struct tr069_instance_node *node;

	ENTER();

	initialize_table_radiusAccServerExtTable();

	/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusClient.Accounting.Server */
	rs = tr069_get_instance_ref_by_selector((tr069_selector){ cwmp__InternetGatewayDevice,
				cwmp__IGD_X_TPLINO_NET_SessionControl,
				cwmp__IGD_SCG_RadiusClient,
				cwmp__IGD_SCG_RC_Accounting,
				cwmp__IGD_SCG_RC_Acct_Server, 0});

	if (!rs) {
		EXIT();
		return;
	}

	for (node = tr069_instance_first(rs);
	     node != NULL;
	     node = tr069_instance_next(rs, node)) {
		/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusClient.Accounting.Server.{i} */

		debug(": adding instance: %d (%p)", node->instance, DM_TABLE(node->table));
		add_radiusAccServerExtTable(node->instance, DM_TABLE(node->table));
	}

	EXIT();
}

/************************************************************
 *
 * Initialize the radiusAccServerExtTable table by defining its contents and how it's structured
 */
void
initialize_table_radiusAccServerExtTable(void)
{
    netsnmp_table_registration_info *table_info;

    if (my_handler) {
        snmp_log(LOG_ERR,
                 "initialize_table_radiusAccServerExtTable_handler called again\n");
        return;
    }

    memset(&cb, 0, sizeof(cb));

    /** create the table structure itself */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    my_handler =
        netsnmp_create_handler_registration("radiusAccServerExtTable",
                                            netsnmp_table_array_helper_handler,
                                            radiusAccServerExtTable_oid,
                                            radiusAccServerExtTable_oid_len,
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info) {
        snmp_log(LOG_ERR, "malloc failed in "
                 "initialize_table_radiusAccServerExtTable_handler\n");
        return; /** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    /*
     * TODO: add any external indexes here.
     */

    /*
     * internal indexes
     */
        /** index: radiusAccServerExtIndex */
    netsnmp_table_helper_add_index(table_info, ASN_INTEGER);

    table_info->min_column = radiusAccServerExtTable_COL_MIN;
    table_info->max_column = radiusAccServerExtTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
    cb.get_value = radiusAccServerExtTable_get_value;
    cb.container =
        netsnmp_container_find("radiusAccServerExtTable_primary:"
                               "radiusAccServerExtTable:"
                               "table_container");

    DEBUGMSGTL(("initialize_table_radiusAccServerExtTable",
                "Registering table radiusAccServerExtTable "
                "as a table array\n"));
    netsnmp_table_container_register(my_handler, table_info, &cb,
                                     cb.container, 1);
}

/************************************************************
 * radiusAccServerExtTable_get_value
 *
 * This routine is called for get requests to copy the data
 * from the context to the varbind for the request. If the
 * context has been properly maintained, you don't need to
 * change in code in this fuction.
 */
int
radiusAccServerExtTable_get_value(netsnmp_request_info *request,
                                  netsnmp_index * item,
                                  netsnmp_table_request_info *table_info)
{
	netsnmp_variable_list *var = request->requestvb;
	radiusAccServerExtTable_context *ctx =
		(radiusAccServerExtTable_context *) item;
	struct rad_server *srv;
	struct rad_server dummy;
	char b1[128];

	ENTER();

	debug("get row: %p, client: %p", ctx, ctx->client);

	if (!ctx->client) {
		snmp_log(LOG_ERR, "invalid server in "
			 "radiusAccServerExtTable_get_value\n");
		EXIT();
		return SNMP_ERR_GENERR;
	}

	debug(": table: %s", sel2str(b1, ctx->client->id));

	/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusClient.Accounting.Server.{i}.X_DM_RadiusServerStruct */
	srv = tr069_get_ptr_by_id(ctx->client, cwmp__IGD_SCG_RC_Acct_Srv_i_X_DM_RadiusServerStruct);
	debug(": RadiusClientStruct: %p", srv);
	if (!srv) {
		memset(&dummy, 0, sizeof(dummy));
		srv = &dummy;
	}

	switch (table_info->colnum) {
	case COLUMN_RADIUSACCSERVERINETADDRESSTYPE:
		/** InetAddressType = ASN_INTEGER */
		snmp_set_var_typed_integer(var, ASN_INTEGER, INETADDRESSTYPE_IPV4);
		break;
		
	case COLUMN_RADIUSACCSERVERINETADDRESS: {
		char hname[NI_MAXHOST];
		struct in_addr host;
		
		/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusClient.Accounting.Server.{i}.IP */
		host = tr069_get_ipv4_by_id(ctx->client, cwmp__IGD_SCG_RC_Acct_Srv_i_IP);
		inet_ntop(AF_INET, &host, hname, sizeof(hname));
		
		/** InetAddress = ASN_OCTET_STR */
		snmp_set_var_typed_value(var, ASN_OCTET_STR, (unsigned char *)hname, strlen(hname));
		break;
	}
			
	case COLUMN_RADIUSACCCLIENTSERVERINETPORTNUMBER:
		/** InetPortNumber = ASN_UNSIGNED */
		/** VAR: InternetGatewayDevice.X_TPLINO_NET_SessionControl.RadiusClient.Accounting.Server.{i}.Port */
		snmp_set_var_typed_integer(var, ASN_UNSIGNED, tr069_get_uint_by_id(ctx->client, cwmp__IGD_SCG_RC_Acct_Srv_i_Port));
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTROUNDTRIPTIME:
		/** TICKS = ASN_TIMETICKS */
		snmp_set_var_typed_integer(var, ASN_TIMETICKS, 0);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTREQUESTS:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.requests);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTRETRANSMISSIONS:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.retransmissions);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTRESPONSES:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.responses);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTMALFORMEDRESPONSES:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.malformed_responses);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTBADAUTHENTICATORS:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.bad_authenticators);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTPENDINGREQUESTS:
		/** GAUGE = ASN_GAUGE */
		snmp_set_var_typed_integer(var, ASN_GAUGE, srv->stats.pending_requests);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTTIMEOUTS:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.timeouts);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTUNKNOWNTYPES:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.unknown_types);
		break;
		
	case COLUMN_RADIUSACCCLIENTEXTPACKETSDROPPED:
		/** COUNTER = ASN_COUNTER */
		snmp_set_var_typed_integer(var, ASN_COUNTER, srv->stats.packets_dropped);
		break;
		
	case COLUMN_RADIUSACCCLIENTCOUNTERDISCONTINUITY:
		/** TICKS = ASN_TIMETICKS */
		snmp_set_var_typed_integer(var, ASN_TIMETICKS,
					   (ltime() - ctx->radiusAccClientCounterDiscontinuity) / 10);
		break;
		
	default:/** We shouldn't get here */
		snmp_log(LOG_ERR, "unknown column in "
			 "radiusAccServerExtTable_get_value\n");
		EXIT();
		return SNMP_ERR_GENERR;
	}

	EXIT();
	return SNMP_ERR_NOERROR;
}
